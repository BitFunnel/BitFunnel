// The MIT License (MIT)

// Copyright (c) 2016, Microsoft

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#pragma once

#include <stddef.h>                         // size_t, ptrdiff_t parameter.
#include <stdint.h>                         // uint32_t embedded.
#include <vector>

#include "BitFunnel/BitFunnelTypes.h"       // Rank parameter.
#include "BitFunnel/Plan/ICodeGenerator.h"  // Base class.
#include "LoggerInterfaces/Check.h"         // CHECK macro used in template code.


namespace BitFunnel
{
    class ByteCodeGenerator;
    class IResultsProcessor;

    //*************************************************************************
    //
    // ByteCodeInterpreter executes a sequence of virtual machine instructions
    // provided by an instance of ByteCodeGenerator. The interpreter is
    // intended as a reference implementation for the native x64 code which is
    // generated by MatchTreeCodeGenerator.
    //
    // Usage pattern:
    //   1. Construct a ByteCodeGenerator.
    //   2. Fill the ByteCodeGenerator with instructions via calls to its
    //      ICodeGenerator methods.
    //   3. Obtain an array of row pointers from the planning pipeline.
    //   4. Construct the ByteCodeInterpreter.
    //   5. Invoke the Run() method.
    //
    //*************************************************************************
    class ByteCodeInterpreter
    {
    public:
        class Instruction;

        // Constructs a ByteCodeInterpreter for the sequence of instructions
        // in a specific ByteCodeGenerator. This interpreter will run against
        // the rows passed as that second parameter.
        //
        // NOTE: This method is a work-in-progress. It will eventually take
        // some sort of IResultsProcessor callback and an array of Shard
        // buffer pointers.
        ByteCodeInterpreter(ByteCodeGenerator const & code,
                            IResultsProcessor & resultsProcessor,
                            size_t sliceCount,
                            char * const * sliceBuffers,
                            size_t iterationsPerSlice,
                            ptrdiff_t const * rowOffsets);

        // Runs the instruction sequence for a specified number of iterations.
        // Each iteration processes a single quadword of row data at the
        // highest rank in the plan.
        void Run();

        // Virtual machine opcodes. With the exception of the End opcode,
        // these values have a 1:1 correspondance with the ICodeGenerator
        // methods.
        enum class Opcode
        {
            AndRow,
            LoadRow,
            LeftShiftOffset,
            RightShiftOffset,
            IncrementOffset,
            Push,
            Pop,
            AndStack,
            Constant,
            Not,
            OrStack,
            UpdateFlags,
            Report,
            Call,
            Jmp,
            Jnz,
            Jz,
            Return,
            End,
            Last
        };

        // Instruction class represents a virtual machine instruction.
        // DESIGN GOALS:
        //   No virtual methods allow for compiler optimizations across calls.
        //   Fast construction.
        //   Fast member access.
        //   Fixed size.
        //   Small size (sizeof(Instruction) == sizeof(uint32_t).
        class Instruction
        {
        private:
            static const uint32_t c_opCodeBits = 5;
            static_assert(static_cast<unsigned>(Opcode::Last) < (1ul << c_opCodeBits),
                          "Instruction::m_opcode does not have enough bits.");

            static const uint32_t c_rowBits = 10;
            static const size_t c_maxRowValue = (1ull << c_rowBits) - 1;

            static const uint32_t c_deltaBits = 4;
            static const size_t c_maxDeltaValue = (1ull << c_deltaBits) - 1;

        public:
            Instruction(Opcode opcode, size_t row = 0ul, size_t delta = 0ul, bool inverted = false)
              : m_opcode(static_cast<uint32_t>(opcode)),
                m_row(static_cast<uint32_t>(row)),
                m_delta(static_cast<uint32_t>(delta)),
                m_inverted(inverted ? 1 : 0)
            {
                CHECK_LT(opcode, Opcode::Last)
                    << "Unknown opcode " << opcode;

                // TODO:
                // CHECK_LE(row, c_maxRowValue)
                //     << "row " << row << " out of range.";

                // CHECK_LE(delta, c_maxDeltaValue)
                //     << "delta " << delta << " out of range.";
            }

            Opcode GetOpcode() const
            {
                return static_cast<Opcode>(m_opcode);
            }

            unsigned GetRow() const
            {
                return m_row;
            }

            unsigned GetDelta() const
            {
                return m_delta;
            }

            bool IsInverted() const
            {
                return m_inverted == 1ul;
            }

        private:
            uint32_t m_opcode : c_opCodeBits;
            uint32_t m_row : c_rowBits;
            uint32_t m_delta : c_deltaBits;
            uint32_t m_inverted : 1;
        };

    private:
        void ProcessOneSlice(size_t slice);

        // Executes the instruction sequence for the specified iteration
        // number.
        void RunOneIteration(char const * sliceBuffer, size_t iteration);

        //
        // Cached constructor parameters.
        //

        std::vector<Instruction> const & m_code;
        std::vector<Instruction const *> const & m_jumpTable;

        IResultsProcessor & m_resultsProcessor;

        size_t m_sliceCount;
        char * const * m_sliceBuffers;
        size_t m_iterationsPerSlice;

        ptrdiff_t const * m_rowOffsets;


        //
        // Virtual machine state.
        //

        // Offset into the row due to rank down operation.
        // Initial read is at offset == 0. A rank down operation forks the
        // computation into offsets 0 and 1.
        size_t m_offset;

        // Instruction pointer.
        Instruction const * m_ip;

        // Accumulator register for logical operations on row data.
        uint64_t m_accumulator;

        // Control flow call stack. Holds return addresses for calls.
        std::vector<Instruction const *> m_callStack;

        // 64-bit value stack for Rank0 methods.
        std::vector<uint64_t> m_valueStack;

        // TODO: Formalize definition and usage of zero flag.
        bool m_zeroFlag;
    };

    inline std::ostream& operator<<(std::ostream& out, const ByteCodeInterpreter::Opcode value)
    {
        out << static_cast<unsigned>(value);
        return out;
    }


    //*************************************************************************
    //
    // ByteCodeGenerator is an implementation of ICodeGenerator that creates
    // a vector of instructions suitable for interpretation by
    // ByteCodeInterpreter.
    //
    // Usage pattern:
    //   Construct ByteCodeGenerator().
    //   Invoke ICodeGenerator methods to create vector of instructions.
    //   Invoke Seal() method. From this point on, the class is read-only.
    //   Pass the ByteCodeGenerator to the ByteCodeInterpreter.
    //
    //*************************************************************************
    class ByteCodeGenerator : public ICodeGenerator
    {
    public:
        // Constructs an ByteCodeGenerator representing an empty instruction
        // sequence.
        ByteCodeGenerator();

        // Call this method after filling with instructions and before passing
        // the ByteCodeGenerator to the ByteCodeInterpreter. The Seal() method
        // appends an `End` instruction and performs error checking.
        //
        // Future versions may patch jump and call sites at this time.
        //
        // Seal() may only be called once. After the class has been sealed,
        // calls to ICodeGenerator methods will throw an exception.
        void Seal();

        // Returns the vector of instructions create by calls to ICodeGenerator
        // methods. Class must be sealed before calling this method.
        std::vector<ByteCodeInterpreter::Instruction> const & GetCode() const;

        // Returns the vector mapping jump labels to target addresses. The
        // targets in this vector were set through a combination of calls to
        // AllocateLabel() and PlaceLabel(). Class must be sealed before
        // calling this method.
        std::vector<ByteCodeInterpreter::Instruction const *> const & GetJumpTable() const;

        //
        // ICodeGenerator methods
        //
        // These methods will throw an exception if invoked after the class has
        // been sealed.
        //

        // RankDown compiler primitives
        virtual void AndRow(size_t row, bool inverted, size_t rankDelta) override;
        virtual void LoadRow(size_t row, bool inverted, size_t rankDelta) override;

        virtual void LeftShiftOffset(size_t shift) override;
        virtual void RightShiftOffset(size_t shift) override;
        virtual void IncrementOffset() override;

        virtual void Push() override;
        virtual void Pop() override;

        // Stack machine primitives
        virtual void AndStack() override;
        virtual void Constant(int value) override;
        virtual void Not() override;
        virtual void OrStack() override;
        virtual void UpdateFlags() override;

        virtual void Report() override;

        // Constrol flow primitives.
        virtual ICodeGenerator::Label AllocateLabel() override;
        virtual void PlaceLabel(Label label) override;
        virtual void Call(Label label) override;
        virtual void Jmp(Label label) override;
        virtual void Jnz(Label label) override;
        virtual void Jz(Label label) override;
        virtual void Return() override;

    private:
        void EnsureSealed(bool sealed) const;

        bool m_sealed;
        std::vector<ByteCodeInterpreter::Instruction> m_code;
        std::vector<ByteCodeInterpreter::Instruction const *> m_jumpTable;
    };
}

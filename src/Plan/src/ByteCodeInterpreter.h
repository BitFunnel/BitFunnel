// The MIT License (MIT)

// Copyright (c) 2016, Microsoft

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#pragma once

#include <stddef.h>                         // size_t, ptrdiff_t parameter.
#include <stdint.h>                         // uint32_t embedded.
#include <vector>                           // std::vector embedded.

#include "BitFunnel/BitFunnelTypes.h"       // Rank parameter.
#include "ICodeGenerator.h"                 // Base class.
#include "LoggerInterfaces/Check.h"         // CHECK macro used in template code.


namespace BitFunnel
{
    class ByteCodeGenerator;
    class CacheLineRecorder;
    class IDiagnosticStream;
    class QueryInstrumentation;
    class ResultsBuffer;

    //*************************************************************************
    //
    // ByteCodeInterpreter executes a sequence of virtual machine instructions
    // provided by an instance of ByteCodeGenerator. The interpreter is
    // intended as a reference implementation for the native x64 code which is
    // generated by MatchTreeCodeGenerator.
    //
    // Usage pattern:
    //   1. Construct a ByteCodeGenerator.
    //   2. Fill the ByteCodeGenerator with instructions via calls to its
    //      ICodeGenerator methods.
    //   3. Obtain an array of row pointers from the planning pipeline.
    //   4. Construct the ByteCodeInterpreter.
    //   5. Invoke the Run() method.
    //
    //*************************************************************************
    class ByteCodeInterpreter
    {
    public:
        class Instruction;

        // Constructs a ByteCodeInterpreter for the sequence of instructions
        // in a specific ByteCodeGenerator. This interpreter will run against
        // the rows passed as that second parameter.
        ByteCodeInterpreter(ByteCodeGenerator const & code,
                            ResultsBuffer & resultsBuffer,
                            size_t sliceCount,
                            void * const * sliceBuffers,
                            size_t iterationsPerSlice,
                            Rank initialRank,
                            ptrdiff_t const * rowOffsets,
                            IDiagnosticStream * diagnosticStream,
                            QueryInstrumentation & instrumentation,
                            CacheLineRecorder * cacheLineRecorder);

        // Runs the instruction sequence for a specified number of iterations.
        // Each iteration processes a single quadword of row data at the
        // highest rank in the plan.  Returns true to indicate early
        // termination.
        bool Run();

        // Virtual machine opcodes. With the exception of the End opcode,
        // these values have a 1:1 correspondance with the ICodeGenerator
        // methods.
        //
        // DESIGN NOTE: this enum should be kept in sync with c_opcodeNames[].
        enum class Opcode
        {
            AndRow,
            LoadRow,
            LeftShiftOffset,
            RightShiftOffset,
            IncrementOffset,
            Push,
            Pop,
            AndStack,
            Constant,
            Not,
            OrStack,
            UpdateFlags,
            Report,
            Call,
            Jmp,
            Jnz,
            Jz,
            Return,
            End,
            Last
        };

        // Instruction class represents a virtual machine instruction.
        // DESIGN GOALS:
        //   No virtual methods allow for compiler optimizations across calls.
        //   Fast construction.
        //   Fast member access.
        //   Fixed size.
        //   Small size (sizeof(Instruction) == sizeof(uint32_t).
        class Instruction
        {
        private:
            static const uint32_t c_opCodeBits = 5;
            static_assert(static_cast<unsigned>(Opcode::Last) < (1ul << c_opCodeBits),
                          "Instruction::m_opcode does not have enough bits.");

            static const uint32_t c_rowBits = 10;
            static const size_t c_maxRowValue = (1ull << c_rowBits) - 1;

            static const uint32_t c_deltaBits = 4;
            static const size_t c_maxDeltaValue = (1ull << c_deltaBits) - 1;

        public:
            Instruction(Opcode opcode, size_t row = 0ul, size_t delta = 0ul, bool inverted = false)
              : m_opcode(static_cast<uint32_t>(opcode)),
                m_row(static_cast<uint32_t>(row)),
                m_delta(static_cast<uint32_t>(delta)),
                m_inverted(inverted ? 1 : 0)
            {
                CHECK_LT(opcode, Opcode::Last)
                    << "Unknown opcode " << opcode;

                // TODO:
                // CHECK_LE(row, c_maxRowValue)
                //     << "row " << row << " out of range.";

                // CHECK_LE(delta, c_maxDeltaValue)
                //     << "delta " << delta << " out of range.";
            }

            Opcode GetOpcode() const
            {
                return static_cast<Opcode>(m_opcode);
            }

            unsigned GetRow() const
            {
                return m_row;
            }

            unsigned GetDelta() const
            {
                return m_delta;
            }

            bool IsInverted() const
            {
                return m_inverted == 1ul;
            }

        private:
            uint32_t m_opcode : c_opCodeBits;
            uint32_t m_row : c_rowBits;
            uint32_t m_delta : c_deltaBits;
            uint32_t m_inverted : 1;
        };

    private:
        //  Returns true to indicate early termination.
        bool ProcessOneSlice(size_t slice);

        // Executes the instruction sequence for the specified iteration
        // number. Returns true to indicate early termination.
        bool RunOneIteration(void const * sliceBuffer, size_t iteration);

        // The 'base' parameter has the rank0 quadword position for the start
        // of the current iteration. The accumulator corresponds to position
        // 'base + offset'.
        void AddResult(uint64_t accumulator,
                       size_t offset,
                       size_t base);

        // The 'base' parameter has the rank0 quadword position for the start
        // of this iteration.
        bool FinishIteration(size_t base, void const * sliceBuffer);

        //
        // Cached constructor parameters.
        //

        std::vector<Instruction> const & m_code;
        std::vector<Instruction const *> const & m_jumpTable;

        ResultsBuffer & m_resultsBuffer;

        size_t m_sliceCount;
        void * const * m_sliceBuffers;
        size_t m_iterationsPerSlice;
        size_t m_initialRank;

        ptrdiff_t const * m_rowOffsets;


        //
        // Virtual machine state.
        //

        // Control flow call stack. Holds return addresses for calls.
        std::vector<Instruction const *> m_callStack;

        // 64-bit value stack for Rank0 methods.
        std::vector<uint64_t> m_valueStack;

        // TODO: Formalize definition and usage of zero flag.
        bool m_zeroFlag;

        // Dedupe buffer. First entry is bitmap indicating which of the
        // remaining 64 entries correspond to accumulators with matches.
        uint64_t m_dedupe[65];

        IDiagnosticStream* m_diagnosticStream;
        QueryInstrumentation& m_instrumentation;
        CacheLineRecorder * m_cacheLineRecorder;
    };


    // TODO: move this to .cpp file?
    // These text constants correspond to the values of the enumeration
    // ByteCodeInterpreter::Opcode.
    static const char* const c_opcodeNames[] = {
            "AndRow",
            "LoadRow",
            "LeftShiftOffset",
            "RightShiftOffset",
            "IncrementOffset",
            "Push",
            "Pop",
            "AndStack",
            "Constant",
            "Not",
            "OrStack",
            "UpdateFlags",
            "Report",
            "Call",
            "Jmp",
            "Jnz",
            "Jz",
            "Return",
            "End",
            "Last"
    };


    inline std::ostream& operator<<(std::ostream& out, const ByteCodeInterpreter::Opcode value)
    {
        // Work-around for what is believed to be a bug in g++ v5.4.0 (among
        // other versions). See detailed discussion in #225.
        //
        // Since clang and gcc define __GNUC__, we check for __GNUC__ and not
        // clang.
#ifdef __GNUC__
#ifndef __clang__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
#endif
#endif
        out << c_opcodeNames[static_cast<size_t>(value)];
#ifdef __GNUC__
#ifndef __clang__
#pragma GCC diagnostic pop
#endif
#endif
        return out;
    }


    //*************************************************************************
    //
    // ByteCodeGenerator is an implementation of ICodeGenerator that creates
    // a vector of instructions suitable for interpretation by
    // ByteCodeInterpreter.
    //
    // Usage pattern:
    //   Construct ByteCodeGenerator().
    //   Invoke ICodeGenerator methods to create vector of instructions.
    //   Invoke Seal() method. From this point on, the class is read-only.
    //   Pass the ByteCodeGenerator to the ByteCodeInterpreter.
    //
    //*************************************************************************
    class ByteCodeGenerator : public ICodeGenerator
    {
    public:
        // Constructs an ByteCodeGenerator representing an empty instruction
        // sequence.
        ByteCodeGenerator();

        // Call this method after filling with instructions and before passing
        // the ByteCodeGenerator to the ByteCodeInterpreter. The Seal() method
        // appends an `End` instruction and performs error checking.
        //
        // Future versions may patch jump and call sites at this time.
        //
        // Seal() may only be called once. After the class has been sealed,
        // calls to ICodeGenerator methods will throw an exception.
        void Seal();

        // Returns the vector of instructions create by calls to ICodeGenerator
        // methods. Class must be sealed before calling this method.
        std::vector<ByteCodeInterpreter::Instruction> const & GetCode() const;

        // Returns the vector mapping jump labels to target addresses. The
        // targets in this vector were set through a combination of calls to
        // AllocateLabel() and PlaceLabel(). Class must be sealed before
        // calling this method.
        std::vector<ByteCodeInterpreter::Instruction const *> const &
            GetJumpTable() const;

        //
        // ICodeGenerator methods
        //
        // These methods will throw an exception if invoked after the class has
        // been sealed.
        //

        // RankDown compiler primitives
        virtual void AndRow(size_t row, bool inverted, size_t rankDelta) override;
        virtual void LoadRow(size_t row, bool inverted, size_t rankDelta) override;

        virtual void LeftShiftOffset(size_t shift) override;
        virtual void RightShiftOffset(size_t shift) override;
        virtual void IncrementOffset() override;

        virtual void Push() override;
        virtual void Pop() override;

        // Stack machine primitives
        virtual void AndStack() override;
        virtual void Constant(int value) override;
        virtual void Not() override;
        virtual void OrStack() override;
        virtual void UpdateFlags() override;

        virtual void Report() override;

        // Control flow primitives.
        virtual ICodeGenerator::Label AllocateLabel() override;
        virtual void PlaceLabel(Label label) override;
        virtual void Call(Label label) override;
        virtual void Jmp(Label label) override;
        virtual void Jnz(Label label) override;
        virtual void Jz(Label label) override;
        virtual void Return() override;

    private:
        void EnsureSealed(bool sealed) const;

        bool m_sealed;
        std::vector<ByteCodeInterpreter::Instruction> m_code;
        std::vector<size_t> m_jumpOffsets;
        std::vector<ByteCodeInterpreter::Instruction const *> m_jumpTable;
    };
}
